{% extends "base.html" %}

{% block title %}Mapowanie Produktów{% endblock %}

{% block content %}
<div class="container mt-4">
    <h1>Mapowanie Produktów z Paragonu</h1>
    <p class="text-muted">Paragon z dnia: {{ paragon.data_zakupu.strftime('%Y-%m-%d') }}</p>
    
    <div id="errorContainer" class="position-fixed top-0 end-0 p-3" style="z-index: 2000"></div>
    
    <div class="mb-3 d-flex flex-wrap gap-2">
        <button type="button" class="btn btn-primary flex-grow-1 flex-md-grow-0" onclick="toggleBulkMode()">
            <i class="fas fa-layer-group"></i> <span class="d-none d-md-inline">Tryb masowego mapowania</span>
            <span class="d-md-none">Masowe</span>
        </button>
        <button type="button" 
                class="btn btn-outline-primary flex-grow-1 flex-md-grow-0" 
                onclick="toggleBatchCategoryMode()">
            <i class="fas fa-tags"></i> <span class="d-none d-md-inline">Mapowanie kategorii</span>
            <span class="d-md-none">Kategorie</span>
        </button>
        <button type="button" 
                class="btn btn-outline-secondary flex-grow-1 flex-md-grow-0" 
                data-bs-toggle="tooltip" 
                data-bs-html="true"
                title="<b>Skróty klawiszowe:</b><br>
                       Alt + M - Tryb masowy<br>
                       Alt + K - Mapowanie kategorii<br>
                       Alt + S - Wyszukaj<br>
                       Alt + N - Dodaj jako nowy<br>
                       Alt + Q - Szybkie mapowanie">
            <i class="fas fa-keyboard"></i> <span class="d-none d-md-inline">Skróty</span>
        </button>
        <div id="bulkProgress" class="progress flex-grow-1" style="display: none;">
            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                 role="progressbar" 
                 style="width: 0%">
            </div>
        </div>
    </div>
    
    {% if flash_msg %}
    <div class="alert alert-info alert-dismissible fade show" role="alert">
        {{ flash_msg }}
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
    {% endif %}
    
    <div class="table-responsive">
        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Nazwa produktu</th>
                    <th class="d-none d-md-table-cell">Kategoria</th>
                    <th>Cena</th>
                    <th class="d-none d-md-table-cell">Ilość</th>
                    <th>Status</th>
                    <th>Akcje</th>
                </tr>
            </thead>
            <tbody>
                {% for produkt in produkty %}
                <tr>
                    <div class="swipe-hint swipe-hint-left">
                        <i class="fas fa-times"></i> Ignoruj
                    </div>
                    <div class="swipe-hint swipe-hint-right">
                        <i class="fas fa-bolt"></i> Szybkie mapowanie
                    </div>
                    <td>
                        {{ produkt.nazwa }}
                        <div class="d-md-none small text-muted">
                            {{ produkt.kategoria }} | {{ produkt.ilosc_na_paragonie }} szt.
                        </div>
                    </td>
                    <td class="d-none d-md-table-cell">{{ produkt.kategoria }}</td>
                    <td>{{ "%.2f"|format(produkt.cena) }} zł</td>
                    <td class="d-none d-md-table-cell">{{ produkt.ilosc_na_paragonie }}</td>
                    <td>
                        {% if produkt.status_mapowania == 'oczekuje' %}
                            <span class="badge bg-warning">Oczekuje</span>
                        {% elif produkt.status_mapowania == 'zmapowany' %}
                            <span class="badge bg-success">Zmapowany</span>
                        {% elif produkt.status_mapowania == 'nowy' %}
                            <span class="badge bg-info">Nowy</span>
                        {% else %}
                            <span class="badge bg-secondary">Ignorowany</span>
                        {% endif %}
                    </td>
                    <td>
                        <div class="btn-group">
                            <button type="button" 
                                    class="btn btn-sm btn-success map-btn" 
                                    onclick="quickMap('{{ produkt.id }}')"
                                    title="Szybkie mapowanie do najbardziej prawdopodobnego produktu">
                                <i class="fas fa-bolt"></i>
                            </button>
                            <button type="button"
                                    class="btn btn-sm btn-primary map-btn" 
                                    data-bs-toggle="modal" 
                                    data-bs-target="#mapModal{{ produkt.id }}">
                                <i class="fas fa-link"></i>
                            </button>
                            <button type="button" 
                                    class="btn btn-sm btn-danger"
                                    onclick="ignoreProduct('{{ produkt.id }}')">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </td>
                </tr>
                
                <!-- Mapping Modal -->
                <div class="modal fade" id="mapModal{{ produkt.id }}" tabindex="-1">
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title">Mapuj produkt: {{ produkt.nazwa }}</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                            <div class="modal-body">
                                <div class="mb-3">
                                    <input type="text" 
                                           class="form-control" 
                                           id="searchProduct{{ produkt.id }}" 
                                           placeholder="Wyszukaj produkt..."
                                           onkeyup="filterProducts('{{ produkt.id }}')">
                                </div>
                                <div class="mb-3">
                                    <select class="form-select" 
                                            id="categoryFilter{{ produkt.id }}"
                                            onchange="filterByCategory('{{ produkt.id }}')">
                                        <option value="">Wszystkie kategorie</option>
                                        <option value="Nabiał">Nabiał</option>
                                        <option value="Pieczywo">Pieczywo</option>
                                        <option value="Mięso">Mięso</option>
                                        <option value="Warzywa">Warzywa</option>
                                        <option value="Owoce">Owoce</option>
                                        <option value="Słodycze">Słodycze</option>
                                        <option value="Napoje">Napoje</option>
                                        <option value="Inne">Inne</option>
                                    </select>
                                </div>

                                <div class="card mb-3">
                                    <div class="card-body">
                                        <h6 class="card-title">Historia produktu</h6>
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <small class="text-muted">Ostatnio kupowany:</small>
                                            <span id="lastPurchase{{ produkt.id }}">-</span>
                                        </div>
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <small class="text-muted">Średnia cena:</small>
                                            <span id="avgPrice{{ produkt.id }}">-</span>
                                        </div>
                                        <div class="d-flex justify-content-between align-items-center">
                                            <small class="text-muted">Częstotliwość zakupów:</small>
                                            <span id="purchaseFreq{{ produkt.id }}">-</span>
                                        </div>
                                    </div>
                                </div>

                                {% if produkt.sugestie_mapowania %}
                                <h6>Sugerowane produkty:</h6>
                                <div class="list-group mb-3">
                                    {% for sugestia in produkt.sugestie_mapowania|from_json %}
                                    <button type="button" 
                                            class="list-group-item list-group-item-action"
                                            onclick="mapToExisting('{{ produkt.id }}', '{{ sugestia.id }}')">
                                        {{ sugestia.nazwa }} ({{ sugestia.kategoria }})
                                        <span class="badge bg-info float-end">
                                            {{ sugestia.podobienstwo }}%
                                        </span>
                                    </button>
                                    {% endfor %}
                                </div>
                                {% endif %}
                                
                                <div class="d-grid gap-2">
                                    <button type="button" 
                                            class="btn btn-success"
                                            onclick="mapAsNew('{{ produkt.id }}')">
                                        <i class="fas fa-plus"></i> Dodaj jako nowy produkt
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                {% endfor %}
            </tbody>
        </table>
    </div>
    
    <div class="mt-3">
        <a href="/paragony" class="btn btn-secondary">
            <i class="fas fa-arrow-left"></i> Powrót do listy paragonów
        </a>
    </div>
</div>

<!-- Batch Category Modal -->
<div class="modal fade" id="batchCategoryModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Mapowanie wsadowe kategorii</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Wybierz kategorię:</label>
                    <select class="form-select" id="batchCategorySelect">
                        <option value="">Wybierz kategorię...</option>
                        <option value="Nabiał">Nabiał</option>
                        <option value="Pieczywo">Pieczywo</option>
                        <option value="Mięso">Mięso</option>
                        <option value="Warzywa">Warzywa</option>
                        <option value="Owoce">Owoce</option>
                        <option value="Słodycze">Słodycze</option>
                        <option value="Napoje">Napoje</option>
                        <option value="Inne">Inne</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label class="form-label">Filtruj produkty:</label>
                    <input type="text" 
                           class="form-control" 
                           id="batchCategorySearch" 
                           placeholder="Wyszukaj produkty..."
                           onkeyup="filterBatchProducts()">
                </div>
                <div class="mb-3">
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="selectAllBatch" onchange="toggleSelectAllBatch()">
                        <label class="form-check-label" for="selectAllBatch">
                            Zaznacz wszystkie
                        </label>
                    </div>
                </div>
                <div id="batchProductsList" class="list-group mb-3" style="max-height: 300px; overflow-y: auto;">
                    <!-- Products will be listed here -->
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Anuluj</button>
                <button type="button" class="btn btn-primary" onclick="applyBatchCategory()">Zastosuj</button>
            </div>
        </div>
    </div>
</div>

<style>
.swipe-hint {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
}

.swipe-hint-left {
    left: 10px;
    color: #dc3545;
}

.swipe-hint-right {
    right: 10px;
    color: #198754;
}

tr {
    position: relative;
}

tr.swiping .swipe-hint {
    opacity: 1;
}

@media (hover: none) {
    .swipe-hint {
        display: block;
    }
}
</style>
{% endblock %}

{% block scripts %}
<script>
// Initialize tooltips
document.addEventListener('DOMContentLoaded', function() {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function(tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });
});

// Add keyboard shortcuts
document.addEventListener('keydown', function(e) {
    // Alt + M to toggle bulk mode
    if (e.altKey && e.key === 'm') {
        e.preventDefault();
        toggleBulkMode();
    }
    
    // Alt + S to focus search in current modal
    if (e.altKey && e.key === 's') {
        e.preventDefault();
        const activeModal = document.querySelector('.modal.show');
        if (activeModal) {
            const searchInput = activeModal.querySelector('input[type="text"]');
            if (searchInput) {
                searchInput.focus();
            }
        }
    }
    
    // Alt + N to map as new product
    if (e.altKey && e.key === 'n') {
        e.preventDefault();
        const activeModal = document.querySelector('.modal.show');
        if (activeModal) {
            const mapAsNewBtn = activeModal.querySelector('button[onclick^="mapAsNew"]');
            if (mapAsNewBtn) {
                mapAsNewBtn.click();
            }
        }
    }

    // Alt + Q for quick mapping
    if (e.altKey && e.key === 'q') {
        e.preventDefault();
        const activeModal = document.querySelector('.modal.show');
        if (activeModal) {
            const productId = activeModal.id.replace('mapModal', '');
            quickMap(productId);
        }
    }

    // Alt + K to toggle batch category mode
    if (e.altKey && e.key === 'k') {
        e.preventDefault();
        toggleBatchCategoryMode();
    }
});

function getCsrfToken() {
    return document.querySelector('meta[name="csrf-token"]').getAttribute('content');
}

// Enhanced error handling system
const ErrorTypes = {
    NETWORK: 'network',
    VALIDATION: 'validation',
    SERVER: 'server',
    UNKNOWN: 'unknown'
};

const ErrorConfig = {
    maxRetries: 3,
    retryDelay: 1000,
    logToConsole: true,
    logToServer: true
};

function logError(error, type, context = {}) {
    const errorLog = {
        timestamp: new Date().toISOString(),
        type,
        message: error.message,
        stack: error.stack,
        context
    };

    if (ErrorConfig.logToConsole) {
        console.error('Error Log:', errorLog);
    }

    if (ErrorConfig.logToServer) {
        DataCompressor.compress(errorLog).then(compressedData => {
            fetch('/api/logs/error', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': getCsrfToken(),
                    'X-Compression': compressedData.compressed ? compressedData.method : 'none'
                },
                body: compressedData.compressed ? 
                    compressedData.data : 
                    JSON.stringify(errorLog)
            }).catch(console.error);
        });
    }
}

async function retryOperation(operation, maxRetries = ErrorConfig.maxRetries) {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return await operation();
        } catch (error) {
            lastError = error;
            if (attempt < maxRetries) {
                await new Promise(resolve => setTimeout(resolve, ErrorConfig.retryDelay * attempt));
            }
        }
    }
    throw lastError;
}

function showError(message, type = ErrorTypes.UNKNOWN, duration = 5000) {
    const errorContainer = document.getElementById('errorContainer');
    const errorDiv = document.createElement('div');
    errorDiv.className = `alert alert-danger alert-dismissible fade show`;
    
    const errorId = `error-${Date.now()}`;
    errorDiv.id = errorId;
    
    errorDiv.innerHTML = `
        <div class="d-flex align-items-center">
            <i class="fas ${getErrorIcon(type)} me-2"></i>
            <div>
                <strong>${getErrorTitle(type)}</strong>
                <p class="mb-0">${message}</p>
                ${type === ErrorTypes.NETWORK ? '<button class="btn btn-sm btn-outline-danger mt-2" onclick="retryLastOperation()">Spróbuj ponownie</button>' : ''}
            </div>
        </div>
        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    `;
    
    errorContainer.appendChild(errorDiv);
    
    setTimeout(() => {
        errorDiv.classList.remove('show');
        setTimeout(() => errorDiv.remove(), 150);
    }, duration);
}

// Store the last failed operation for retry
let lastFailedOperation = null;

function retryLastOperation() {
    if (lastFailedOperation) {
        lastFailedOperation();
    }
}

function getErrorIcon(type) {
    switch(type) {
        case ErrorTypes.NETWORK: return 'fa-wifi';
        case ErrorTypes.VALIDATION: return 'fa-exclamation-circle';
        case ErrorTypes.SERVER: return 'fa-server';
        default: return 'fa-exclamation-triangle';
    }
}

function getErrorTitle(type) {
    switch(type) {
        case ErrorTypes.NETWORK: return 'Błąd połączenia';
        case ErrorTypes.VALIDATION: return 'Błąd walidacji';
        case ErrorTypes.SERVER: return 'Błąd serwera';
        default: return 'Wystąpił błąd';
    }
}

// Undo/Redo system
const OperationTypes = {
    MAP: 'map',
    IGNORE: 'ignore',
    NEW: 'new',
    BATCH_CATEGORY: 'batch_category'
};

class OperationHistory {
    constructor() {
        this.undoStack = [];
        this.redoStack = [];
        this.maxStackSize = 50;
    }

    push(operation) {
        this.undoStack.push(operation);
        this.redoStack = []; // Clear redo stack when new operation is performed
        if (this.undoStack.length > this.maxStackSize) {
            this.undoStack.shift();
        }
    }

    undo() {
        if (this.undoStack.length === 0) return null;
        const operation = this.undoStack.pop();
        this.redoStack.push(operation);
        return operation;
    }

    redo() {
        if (this.redoStack.length === 0) return null;
        const operation = this.redoStack.pop();
        this.undoStack.push(operation);
        return operation;
    }

    canUndo() {
        return this.undoStack.length > 0;
    }

    canRedo() {
        return this.redoStack.length > 0;
    }
}

const operationHistory = new OperationHistory();

// Add undo/redo buttons to the UI
document.addEventListener('DOMContentLoaded', function() {
    const buttonContainer = document.querySelector('.mb-3.d-flex');
    const undoButton = document.createElement('button');
    undoButton.className = 'btn btn-outline-secondary flex-grow-1 flex-md-grow-0';
    undoButton.innerHTML = '<i class="fas fa-undo"></i> <span class="d-none d-md-inline">Cofnij</span>';
    undoButton.onclick = handleUndo;
    undoButton.disabled = true;

    const redoButton = document.createElement('button');
    redoButton.className = 'btn btn-outline-secondary flex-grow-1 flex-md-grow-0';
    redoButton.innerHTML = '<i class="fas fa-redo"></i> <span class="d-none d-md-inline">Ponów</span>';
    redoButton.onclick = handleRedo;
    redoButton.disabled = true;

    buttonContainer.insertBefore(redoButton, buttonContainer.firstChild);
    buttonContainer.insertBefore(undoButton, buttonContainer.firstChild);

    // Add keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey || e.metaKey) {
            if (e.key === 'z') {
                e.preventDefault();
                if (e.shiftKey) {
                    handleRedo();
                } else {
                    handleUndo();
                }
            } else if (e.key === 'y') {
                e.preventDefault();
                handleRedo();
            }
        }
    });
});

function updateUndoRedoButtons() {
    const undoButton = document.querySelector('button[onclick="handleUndo()"]');
    const redoButton = document.querySelector('button[onclick="handleRedo()"]');
    if (undoButton) undoButton.disabled = !operationHistory.canUndo();
    if (redoButton) redoButton.disabled = !operationHistory.canRedo();
}

async function handleUndo() {
    const operation = operationHistory.undo();
    if (!operation) return;

    try {
        switch (operation.type) {
            case OperationTypes.MAP:
                await undoMap(operation);
                break;
            case OperationTypes.IGNORE:
                await undoIgnore(operation);
                break;
            case OperationTypes.NEW:
                await undoNew(operation);
                break;
            case OperationTypes.BATCH_CATEGORY:
                await undoBatchCategory(operation);
                break;
        }
        showNotification('Operacja cofnięta', 2000);
        updateUndoRedoButtons();
    } catch (error) {
        console.error('Error during undo:', error);
        showError('Nie udało się cofnąć operacji', ErrorTypes.SERVER);
        operationHistory.undoStack.push(operation);
        updateUndoRedoButtons();
    }
}

async function handleRedo() {
    const operation = operationHistory.redo();
    if (!operation) return;

    try {
        switch (operation.type) {
            case OperationTypes.MAP:
                await redoMap(operation);
                break;
            case OperationTypes.IGNORE:
                await redoIgnore(operation);
                break;
            case OperationTypes.NEW:
                await redoNew(operation);
                break;
            case OperationTypes.BATCH_CATEGORY:
                await redoBatchCategory(operation);
                break;
        }
        showNotification('Operacja ponowiona', 2000);
        updateUndoRedoButtons();
    } catch (error) {
        console.error('Error during redo:', error);
        showError('Nie udało się ponowić operacji', ErrorTypes.SERVER);
        operationHistory.redoStack.push(operation);
        updateUndoRedoButtons();
    }
}

// Product history caching system
const HistoryCache = {
    cache: new Map(),
    maxCacheSize: 50,
    pendingRequests: new Map(),
    cacheTimeout: 5 * 60 * 1000, // 5 minutes
    
    async getHistory(productId) {
        const cacheKey = `history-${productId}`;
        const cachedData = this.cache.get(cacheKey);
        
        // Return cached data if it's still valid
        if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {
            return cachedData.data;
        }
        
        // Return pending request if exists
        if (this.pendingRequests.has(cacheKey)) {
            return this.pendingRequests.get(cacheKey);
        }
        
        // Create new request
        const request = this.fetchHistory(productId);
        this.pendingRequests.set(cacheKey, request);
        
        try {
            const results = await request;
            this.cache.set(cacheKey, {
                data: results,
                timestamp: Date.now()
            });
            
            // Manage cache size
            if (this.cache.size > this.maxCacheSize) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }
            
            return results;
        } finally {
            this.pendingRequests.delete(cacheKey);
        }
    },
    
    async fetchHistory(productId) {
        const response = await fetch(`/api/produkty/historia/${productId}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.status !== 'success') {
            throw new Error(data.message || 'Błąd podczas ładowania historii produktu');
        }
        return data.history;
    },
    
    clearCache() {
        this.cache.clear();
        this.pendingRequests.clear();
    },
    
    invalidateCache(productId) {
        const cacheKey = `history-${productId}`;
        this.cache.delete(cacheKey);
    }
};

// Update loadProductHistory function to use cache
async function loadProductHistory(productId) {
    const historyContainer = document.querySelector(`#mapModal${productId} .card-body`);
    const loadingHtml = `
        <div class="d-flex justify-content-center">
            <div class="spinner-border spinner-border-sm text-primary" role="status">
                <span class="visually-hidden">Ładowanie...</span>
            </div>
        </div>
    `;
    
    // Show loading state
    document.getElementById(`lastPurchase${productId}`).innerHTML = loadingHtml;
    document.getElementById(`avgPrice${productId}`).innerHTML = loadingHtml;
    document.getElementById(`purchaseFreq${productId}`).innerHTML = loadingHtml;
    
    try {
        const history = await HistoryCache.getHistory(productId);
        
        document.getElementById(`lastPurchase${productId}`).textContent = 
            history.last_purchase ? new Date(history.last_purchase).toLocaleDateString() : 'Nigdy';
        document.getElementById(`avgPrice${productId}`).textContent = 
            history.avg_price ? `${history.avg_price.toFixed(2)} zł` : '-';
        document.getElementById(`purchaseFreq${productId}`).textContent = 
            history.purchase_frequency ? `${history.purchase_frequency} dni` : '-';
    } catch (error) {
        console.error('Error loading product history:', error);
        document.getElementById(`lastPurchase${productId}`).textContent = '-';
        document.getElementById(`avgPrice${productId}`).textContent = '-';
        document.getElementById(`purchaseFreq${productId}`).textContent = '-';
        showError(
            error.message || 'Wystąpił błąd podczas ładowania historii produktu',
            error.name === 'TypeError' ? ErrorTypes.NETWORK : ErrorTypes.SERVER
        );
    }
}

// Update mapToExisting to invalidate history cache
async function mapToExisting(receiptProductId, pantryProductId) {
    const operation = async () => {
        const response = await fetch(`/api/produkty/mapuj/${receiptProductId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': getCsrfToken()
            },
            body: JSON.stringify({
                pantry_product_id: pantryProductId
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (data.status !== 'success') {
            throw new Error(data.message || 'Błąd podczas mapowania produktu');
        }

        // Invalidate history cache for this product
        HistoryCache.invalidateCache(receiptProductId);

        // Store operation in history
        operationHistory.push({
            type: OperationTypes.MAP,
            receiptProductId,
            pantryProductId,
            previousStatus: getCurrentStatus(receiptProductId)
        });

        showNotification('Produkt został zmapowany!', 2000);
        updateRowStatus(receiptProductId, 'zmapowany');
        updateUndoRedoButtons();
    };

    try {
        await retryOperation(operation);
    } catch (error) {
        console.error('Error:', error);
        logError(error, ErrorTypes.SERVER, { receiptProductId, pantryProductId });
        lastFailedOperation = () => mapToExisting(receiptProductId, pantryProductId);
        showError(
            error.message || 'Wystąpił błąd podczas mapowania produktu',
            error.name === 'TypeError' ? ErrorTypes.NETWORK : ErrorTypes.SERVER
        );
    }
}

// Helper functions for undo/redo operations
function getCurrentStatus(productId) {
    const row = document.querySelector(`button[data-bs-target='#mapModal${productId}']`).closest('tr');
    const statusBadge = row.querySelector('.badge');
    return statusBadge ? statusBadge.textContent.toLowerCase() : 'oczekuje';
}

async function undoMap(operation) {
    const response = await fetch(`/api/produkty/cofnij-mapowanie/${operation.receiptProductId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': getCsrfToken()
        }
    });

    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    if (data.status !== 'success') {
        throw new Error(data.message || 'Błąd podczas cofania mapowania');
    }

    updateRowStatus(operation.receiptProductId, operation.previousStatus);
}

async function redoMap(operation) {
    await mapToExisting(operation.receiptProductId, operation.pantryProductId);
}

async function mapAsNew(receiptProductId) {
    const operation = async () => {
        const response = await fetch(`/api/produkty/mapuj/${receiptProductId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': getCsrfToken()
            },
            body: JSON.stringify({
                map_as_new: true
            })
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (data.status !== 'success') {
            throw new Error(data.message || 'Błąd podczas mapowania produktu');
        }

        // Store operation in history
        operationHistory.push({
            type: OperationTypes.NEW,
            receiptProductId,
            previousStatus: getCurrentStatus(receiptProductId)
        });

        showNotification('Produkt dodany jako nowy!', 2000);
        updateRowStatus(receiptProductId, 'nowy');
        updateUndoRedoButtons();
    };

    try {
        await retryOperation(operation);
    } catch (error) {
        console.error('Error:', error);
        logError(error, ErrorTypes.SERVER, { receiptProductId });
        lastFailedOperation = () => mapAsNew(receiptProductId);
        showError(
            error.message || 'Wystąpił błąd podczas mapowania produktu',
            error.name === 'TypeError' ? ErrorTypes.NETWORK : ErrorTypes.SERVER
        );
    }
}

async function ignoreProduct(receiptProductId) {
    if (!confirm('Czy na pewno chcesz zignorować ten produkt?')) {
        return;
    }

    const operation = async () => {
        const response = await fetch(`/api/produkty/ignoruj/${receiptProductId}`, {
            method: 'POST',
            headers: {
                'X-CSRF-Token': getCsrfToken()
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        if (data.status !== 'success') {
            throw new Error(data.message || 'Błąd podczas ignorowania produktu');
        }

        // Store operation in history
        operationHistory.push({
            type: OperationTypes.IGNORE,
            receiptProductId,
            previousStatus: getCurrentStatus(receiptProductId)
        });

        showNotification('Produkt zignorowany!', 2000);
        updateRowStatus(receiptProductId, 'ignorowany');
        updateUndoRedoButtons();
    };

    try {
        await retryOperation(operation);
    } catch (error) {
        console.error('Error:', error);
        logError(error, ErrorTypes.SERVER, { receiptProductId });
        lastFailedOperation = () => ignoreProduct(receiptProductId);
        showError(
            error.message || 'Wystąpił błąd podczas ignorowania produktu',
            error.name === 'TypeError' ? ErrorTypes.NETWORK : ErrorTypes.SERVER
        );
    }
}

async function undoIgnore(operation) {
    const response = await fetch(`/api/produkty/cofnij-ignorowanie/${operation.receiptProductId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': getCsrfToken()
        }
    });

    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    if (data.status !== 'success') {
        throw new Error(data.message || 'Błąd podczas cofania ignorowania');
    }

    updateRowStatus(operation.receiptProductId, operation.previousStatus);
}

async function redoIgnore(operation) {
    await ignoreProduct(operation.receiptProductId);
}

async function undoNew(operation) {
    const response = await fetch(`/api/produkty/cofnij-nowy/${operation.receiptProductId}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': getCsrfToken()
        }
    });

    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    if (data.status !== 'success') {
        throw new Error(data.message || 'Błąd podczas cofania dodania nowego produktu');
    }

    updateRowStatus(operation.receiptProductId, operation.previousStatus);
}

async function redoNew(operation) {
    await mapAsNew(operation.receiptProductId);
}

// Bulk operations optimization
const BulkOperations = {
    batchSize: 5,
    maxConcurrent: 3,
    retryAttempts: 3,
    retryDelay: 1000,
    
    async processBatch(products, pantryProductId, onProgress, onError) {
        const batches = [];
        for (let i = 0; i < products.length; i += this.batchSize) {
            batches.push(products.slice(i, i + this.batchSize));
        }
        
        let completed = 0;
        let errors = [];
        let previousStatuses = new Map();
        
        // Store previous statuses
        products.forEach(id => {
            previousStatuses.set(id, getCurrentStatus(id));
        });
        
        // Process batches with concurrency limit
        const processBatchWithRetry = async (batch) => {
            const results = await Promise.all(
                batch.map(productId => this.processWithRetry(productId, pantryProductId))
            );
            
            results.forEach((result, index) => {
                const productId = batch[index];
                if (result.error) {
                    errors.push({ productId, error: result.error });
                }
                completed++;
                onProgress(completed, products.length);
            });
        };
        
        // Process batches with concurrency control
        for (let i = 0; i < batches.length; i += this.maxConcurrent) {
            const currentBatches = batches.slice(i, i + this.maxConcurrent);
            await Promise.all(currentBatches.map(processBatchWithRetry));
        }
        
        return { errors, previousStatuses };
    },
    
    async processWithRetry(productId, pantryProductId) {
        for (let attempt = 1; attempt <= this.retryAttempts; attempt++) {
            try {
                const requestData = {
                    receiptProductId: productId,
                    pantryProductId: pantryProductId
                };
                
                const compressedData = await DataCompressor.compress(requestData);
                
                const response = await fetch(`/api/produkty/mapuj/${productId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCsrfToken(),
                        'X-Compression': compressedData.compressed ? compressedData.method : 'none'
                    },
                    body: compressedData.compressed ? 
                        compressedData.data : 
                        JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const responseData = await response.json();
                if (responseData.status !== 'success') {
                    throw new Error(responseData.message || 'Błąd podczas mapowania produktu');
                }
                
                return { success: true };
            } catch (error) {
                if (attempt === this.retryAttempts) {
                    return { error: error.message };
                }
                await new Promise(resolve => setTimeout(resolve, this.retryDelay * attempt));
            }
        }
    }
};

// Update bulkMapProducts function to use optimized bulk operations
async function bulkMapProducts(pantryProductId) {
    if (selectedProducts.size === 0) {
        showError('Wybierz produkty do zmapowania', ErrorTypes.VALIDATION);
        return;
    }
    
    const progressBar = document.getElementById('bulkProgress');
    const progressBarInner = progressBar.querySelector('.progress-bar');
    progressBar.style.display = 'flex';
    progressBarInner.style.width = '0%';
    
    const products = Array.from(selectedProducts);
    
    try {
        const { errors, previousStatuses } = await BulkOperations.processBatch(
            products,
            pantryProductId,
            (completed, total) => {
                const progress = (completed / total) * 100;
                progressBarInner.style.width = `${progress}%`;
            },
            (error) => {
                console.error('Error during bulk operation:', error);
            }
        );
        
        if (errors.length === 0) {
            // Store bulk operation in history
            operationHistory.push({
                type: OperationTypes.MAP,
                isBulk: true,
                products: products.map(id => ({
                    receiptProductId: id,
                    pantryProductId,
                    previousStatus: previousStatuses.get(id)
                }))
            });
            
            showNotification('Wszystkie produkty zostały zmapowane!', 2000);
            selectedProducts.forEach(id => updateRowStatus(id, 'zmapowany'));
            toggleBulkMode();
            updateUndoRedoButtons();
        } else {
            showError(
                `Zmapowano ${products.length - errors.length} z ${products.length} produktów. ${errors.length} błędów.`,
                ErrorTypes.VALIDATION
            );
            errors.forEach(({ productId }) => {
                const row = document.querySelector(`button[data-bs-target='#mapModal${productId}']`).closest('tr');
                row.classList.add('table-danger');
            });
        }
    } catch (error) {
        console.error('Error:', error);
        showError(
            'Wystąpił błąd podczas mapowania produktów',
            ErrorTypes.SERVER
        );
    } finally {
        setTimeout(() => {
            progressBar.style.display = 'none';
            progressBarInner.style.width = '0%';
        }, 1000);
    }
}

// Add bulk operation recovery
async function recoverBulkOperation(operation) {
    if (!operation.isBulk) return;
    
    const progressBar = document.getElementById('bulkProgress');
    const progressBarInner = progressBar.querySelector('.progress-bar');
    progressBar.style.display = 'flex';
    progressBarInner.style.width = '0%';
    
    const products = operation.products.map(p => p.receiptProductId);
    const pantryProductId = operation.products[0].pantryProductId;
    
    try {
        const { errors } = await BulkOperations.processBatch(
            products,
            pantryProductId,
            (completed, total) => {
                const progress = (completed / total) * 100;
                progressBarInner.style.width = `${progress}%`;
            }
        );
        
        if (errors.length === 0) {
            showNotification('Operacja masowa została przywrócona!', 2000);
            products.forEach(id => updateRowStatus(id, 'zmapowany'));
        } else {
            showError(
                `Przywrócono ${products.length - errors.length} z ${products.length} produktów. ${errors.length} błędów.`,
                ErrorTypes.VALIDATION
            );
        }
    } catch (error) {
        console.error('Error during recovery:', error);
        showError('Wystąpił błąd podczas przywracania operacji masowej', ErrorTypes.SERVER);
    } finally {
        setTimeout(() => {
            progressBar.style.display = 'none';
            progressBarInner.style.width = '0%';
        }, 1000);
    }
}

function quickMap(productId) {
    const modal = document.getElementById(`mapModal${productId}`);
    const firstSuggestion = modal.querySelector('.list-group-item');
    
    if (firstSuggestion) {
        const productName = firstSuggestion.textContent.split('(')[0].trim();
        if (confirm(`Czy chcesz zmapować do produktu "${productName}"?`)) {
            const pantryProductId = firstSuggestion.getAttribute('onclick').match(/mapToExisting\([^,]+,\s*(\d+)\)/)[1];
            mapToExisting(productId, pantryProductId);
        }
    } else {
        showNotification('Brak sugestii mapowania dla tego produktu', 3000);
    }
}

// Add event listener for modal show
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('[data-bs-toggle="modal"]').forEach(button => {
        button.addEventListener('click', function() {
            const productId = this.getAttribute('data-bs-target').replace('#mapModal', '');
            const modal = document.getElementById(`mapModal${productId}`);
            
            // Add debounced search
            const searchInput = modal.querySelector('input[type="text"]');
            searchInput.addEventListener('input', debounce(() => filterProducts(productId), 300));
            
            // Load initial suggestions
            setTimeout(() => filterProducts(productId), 100);
            
            // Load product history
            setTimeout(() => loadProductHistory(productId), 100);
        });
    });
});

// Add touch swipe functionality
let touchStartX = 0;
let touchEndX = 0;
let isSwiping = false;

document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('tbody tr').forEach(row => {
        row.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            isSwiping = true;
            row.classList.add('swiping');
        }, false);
        
        row.addEventListener('touchmove', e => {
            if (isSwiping) {
                const currentX = e.changedTouches[0].screenX;
                const swipeDistance = currentX - touchStartX;
                row.style.transform = `translateX(${swipeDistance}px)`;
            }
        }, false);
        
        row.addEventListener('touchend', e => {
            touchEndX = e.changedTouches[0].screenX;
            isSwiping = false;
            row.classList.remove('swiping');
            row.style.transform = '';
            handleSwipe(row);
        }, false);
        
        row.addEventListener('touchcancel', () => {
            isSwiping = false;
            row.classList.remove('swiping');
            row.style.transform = '';
        }, false);
    });
});

function handleSwipe(row) {
    const swipeDistance = touchEndX - touchStartX;
    const productId = row.querySelector('button[data-bs-target]').getAttribute('data-bs-target').replace('#mapModal', '');
    
    // Swipe right for quick map
    if (swipeDistance > 100) {
        quickMap(productId);
    }
    // Swipe left for ignore
    else if (swipeDistance < -100) {
        if (confirm('Czy na pewno chcesz zignorować ten produkt?')) {
            ignoreProduct(productId);
        }
    }
}

// Lazy loading system for suggestions
const SuggestionCache = {
    cache: new Map(),
    maxCacheSize: 100,
    pendingRequests: new Map(),
    
    async getSuggestions(productId, searchTerm = '', category = '') {
        const cacheKey = `${productId}-${searchTerm}-${category}`;
        
        // Return cached results if available
        if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
        }
        
        // Return pending request if exists
        if (this.pendingRequests.has(cacheKey)) {
            return this.pendingRequests.get(cacheKey);
        }
        
        // Create new request
        const request = this.fetchSuggestions(productId, searchTerm, category);
        this.pendingRequests.set(cacheKey, request);
        
        try {
            const results = await request;
            this.cache.set(cacheKey, results);
            
            // Manage cache size
            if (this.cache.size > this.maxCacheSize) {
                const firstKey = this.cache.keys().next().value;
                this.cache.delete(firstKey);
            }
            
            return results;
        } finally {
            this.pendingRequests.delete(cacheKey);
        }
    },
    
    async fetchSuggestions(productId, searchTerm, category) {
        const response = await fetch(`/api/produkty/sugestie/${productId}?search=${encodeURIComponent(searchTerm)}&category=${encodeURIComponent(category)}`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.status !== 'success') {
            throw new Error(data.message || 'Błąd podczas pobierania sugestii');
        }
        return data.suggestions;
    },
    
    clearCache() {
        this.cache.clear();
        this.pendingRequests.clear();
    }
};

// API request optimization system
const ApiOptimizer = {
    requestQueue: new Map(),
    responseCache: new Map(),
    cacheTimeout: 5 * 60 * 1000, // 5 minutes
    batchTimeout: 100, // ms
    pendingBatches: new Map(),
    
    // Batch similar requests
    async batchRequest(endpoint, params, options = {}) {
        const cacheKey = this.getCacheKey(endpoint, params);
        
        // Check cache first
        const cachedData = this.getCachedResponse(cacheKey);
        if (cachedData) {
            return cachedData;
        }
        
        // Add to existing batch or create new one
        if (!this.pendingBatches.has(endpoint)) {
            this.pendingBatches.set(endpoint, {
                params: [],
                promise: null,
                timeout: null
            });
        }
        
        const batch = this.pendingBatches.get(endpoint);
        batch.params.push(params);
        
        // Clear existing timeout
        if (batch.timeout) {
            clearTimeout(batch.timeout);
        }
        
        // Create new promise if none exists
        if (!batch.promise) {
            batch.promise = new Promise((resolve) => {
                batch.timeout = setTimeout(async () => {
                    const results = await this.executeBatch(endpoint, batch.params, options);
                    this.pendingBatches.delete(endpoint);
                    resolve(results);
                }, this.batchTimeout);
            });
        }
        
        return batch.promise.then(results => {
            const index = batch.params.indexOf(params);
            return results[index];
        });
    },
    
    // Execute batched request
    async executeBatch(endpoint, paramsList, options = {}) {
        // Compress request data
        const compressedData = await DataCompressor.compress({
            batch: paramsList
        });
        
        const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': getCsrfToken(),
                'X-Compression': compressedData.compressed ? compressedData.method : 'none',
                ...options.headers
            },
            body: compressedData.compressed ? 
                compressedData.data : 
                JSON.stringify({ batch: paramsList })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const contentType = response.headers.get('Content-Type');
        let data;
        
        if (contentType && contentType.includes('application/json')) {
            const responseData = await response.json();
            if (responseData.status !== 'success') {
                throw new Error(responseData.message || 'Błąd podczas wykonywania zapytania');
            }
            
            // Decompress response data if needed
            if (responseData.compressed) {
                data = await DataCompressor.decompress(responseData);
            } else {
                data = responseData;
            }
        } else {
            throw new Error('Invalid response format');
        }
        
        // Cache results
        data.results.forEach((result, index) => {
            const cacheKey = this.getCacheKey(endpoint, paramsList[index]);
            this.cacheResponse(cacheKey, result);
        });
        
        return data.results;
    },
    
    // Cache management
    getCacheKey(endpoint, params) {
        return `${endpoint}-${JSON.stringify(params)}`;
    },
    
    getCachedResponse(cacheKey) {
        const cached = this.responseCache.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
            return cached.data;
        }
        this.responseCache.delete(cacheKey);
        return null;
    },
    
    cacheResponse(cacheKey, data) {
        this.responseCache.set(cacheKey, {
            data,
            timestamp: Date.now()
        });
        
        // Cleanup old cache entries
        if (this.responseCache.size > 100) {
            const oldestKey = this.responseCache.keys().next().value;
            this.responseCache.delete(oldestKey);
        }
    },
    
    // Clear cache for specific endpoint or all
    clearCache(endpoint = null) {
        if (endpoint) {
            for (const key of this.responseCache.keys()) {
                if (key.startsWith(endpoint)) {
                    this.responseCache.delete(key);
                }
            }
        } else {
            this.responseCache.clear();
        }
    }
};

// Update filter functions to use lazy loading
async function filterProducts(productId) {
    const searchInput = document.getElementById(`searchProduct${productId}`);
    const searchText = searchInput.value.toLowerCase();
    const categoryFilter = document.getElementById(`categoryFilter${productId}`);
    const selectedCategory = categoryFilter.value;
    
    const suggestionsContainer = document.querySelector(`#mapModal${productId} .list-group`);
    suggestionsContainer.innerHTML = '<div class="text-center p-3"><div class="spinner-border text-primary" role="status"></div></div>';
    
    try {
        const suggestions = await ApiOptimizer.batchRequest(
            '/api/produkty/sugestie',
            { productId, search: searchText, category: selectedCategory }
        );
        
        if (suggestions.length === 0) {
            suggestionsContainer.innerHTML = '<div class="text-center p-3 text-muted">Brak sugestii</div>';
            return;
        }
        
        suggestionsContainer.innerHTML = suggestions.map(suggestion => `
            <button type="button" 
                    class="list-group-item list-group-item-action"
                    onclick="mapToExisting('${productId}', '${suggestion.id}')">
                ${suggestion.nazwa} (${suggestion.kategoria})
                <span class="badge bg-info float-end">
                    ${suggestion.podobienstwo}%
                </span>
            </button>
        `).join('');
    } catch (error) {
        console.error('Error loading suggestions:', error);
        suggestionsContainer.innerHTML = '<div class="text-center p-3 text-danger">Błąd podczas ładowania sugestii</div>';
        showError(
            error.message || 'Wystąpił błąd podczas ładowania sugestii',
            error.name === 'TypeError' ? ErrorTypes.NETWORK : ErrorTypes.SERVER
        );
    }
}

async function filterByCategory(productId) {
    await filterProducts(productId);
}

// Add debounce to search input
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Clear cache when leaving the page
window.addEventListener('beforeunload', () => {
    SuggestionCache.clearCache();
    HistoryCache.clearCache();
    ApiOptimizer.clearCache();
    DataCompressor.methods = {}; // Clear compression methods
});

// Data compression system
const DataCompressor = {
    // Compression methods
    methods: {
        gzip: {
            compress: async (data) => {
                const blob = new Blob([JSON.stringify(data)]);
                const compressed = await blob.arrayBuffer();
                return compressed;
            },
            decompress: async (data) => {
                const blob = new Blob([data]);
                const text = await blob.text();
                return JSON.parse(text);
            }
        },
        deflate: {
            compress: async (data) => {
                const text = JSON.stringify(data);
                const encoder = new TextEncoder();
                const uint8Array = encoder.encode(text);
                return uint8Array;
            },
            decompress: async (data) => {
                const decoder = new TextDecoder();
                const text = decoder.decode(data);
                return JSON.parse(text);
            }
        }
    },
    
    // Default compression method
    defaultMethod: 'gzip',
    
    // Compression level (0-9)
    compressionLevel: 6,
    
    // Minimum size to compress (bytes)
    minSizeToCompress: 1024,
    
    // Compress data
    async compress(data, method = this.defaultMethod) {
        try {
            const jsonString = JSON.stringify(data);
            if (jsonString.length < this.minSizeToCompress) {
                return {
                    compressed: false,
                    data: data
                };
            }
            
            const compressed = await this.methods[method].compress(data);
            return {
                compressed: true,
                method: method,
                data: compressed
            };
        } catch (error) {
            console.error('Compression error:', error);
            return {
                compressed: false,
                data: data
            };
        }
    },
    
    // Decompress data
    async decompress(data, method = this.defaultMethod) {
        try {
            if (!data.compressed) {
                return data.data;
            }
            
            return await this.methods[data.method].decompress(data.data);
        } catch (error) {
            console.error('Decompression error:', error);
            throw new Error('Failed to decompress data');
        }
    }
};

// Batch category mapping system
const BatchCategoryMapping = {
    selectedProducts: new Set(),
    currentCategory: '',
    
    init() {
        this.selectedProducts.clear();
        this.currentCategory = '';
        document.getElementById('batchCategorySelect').value = '';
        document.getElementById('batchCategorySearch').value = '';
        document.getElementById('selectAllBatch').checked = false;
        this.updateProductsList();
    },
    
    async updateProductsList() {
        const searchTerm = document.getElementById('batchCategorySearch').value.toLowerCase();
        const productsList = document.getElementById('batchProductsList');
        productsList.innerHTML = '<div class="text-center p-3"><div class="spinner-border text-primary" role="status"></div></div>';
        
        try {
            const products = await ApiOptimizer.batchRequest(
                '/api/produkty/lista',
                { search: searchTerm }
            );
            
            if (products.length === 0) {
                productsList.innerHTML = '<div class="text-center p-3 text-muted">Brak produktów</div>';
                return;
            }
            
            productsList.innerHTML = products.map(product => `
                <label class="list-group-item">
                    <div class="d-flex align-items-center">
                        <input class="form-check-input me-2" 
                               type="checkbox" 
                               value="${product.id}"
                               ${this.selectedProducts.has(product.id) ? 'checked' : ''}
                               onchange="BatchCategoryMapping.toggleProduct('${product.id}')">
                        <div>
                            <div>${product.nazwa}</div>
                            <small class="text-muted">${product.kategoria || 'Brak kategorii'}</small>
                        </div>
                    </div>
                </label>
            `).join('');
        } catch (error) {
            console.error('Error loading products:', error);
            productsList.innerHTML = '<div class="text-center p-3 text-danger">Błąd podczas ładowania produktów</div>';
            showError(
                error.message || 'Wystąpił błąd podczas ładowania produktów',
                error.name === 'TypeError' ? ErrorTypes.NETWORK : ErrorTypes.SERVER
            );
        }
    },
    
    toggleProduct(productId) {
        if (this.selectedProducts.has(productId)) {
            this.selectedProducts.delete(productId);
        } else {
            this.selectedProducts.add(productId);
        }
        document.getElementById('selectAllBatch').checked = 
            this.selectedProducts.size === document.querySelectorAll('#batchProductsList input[type="checkbox"]').length;
    },
    
    toggleSelectAll() {
        const checkboxes = document.querySelectorAll('#batchProductsList input[type="checkbox"]');
        const selectAll = document.getElementById('selectAllBatch').checked;
        
        checkboxes.forEach(checkbox => {
            checkbox.checked = selectAll;
            if (selectAll) {
                this.selectedProducts.add(checkbox.value);
            } else {
                this.selectedProducts.delete(checkbox.value);
            }
        });
    },
    
    async applyCategory() {
        if (this.selectedProducts.size === 0) {
            showError('Wybierz produkty do zmapowania', ErrorTypes.VALIDATION);
            return;
        }
        
        if (!this.currentCategory) {
            showError('Wybierz kategorię', ErrorTypes.VALIDATION);
            return;
        }
        
        const progressBar = document.getElementById('bulkProgress');
        const progressBarInner = progressBar.querySelector('.progress-bar');
        progressBar.style.display = 'flex';
        progressBarInner.style.width = '0%';
        
        const products = Array.from(this.selectedProducts);
        let completed = 0;
        let errors = [];
        
        try {
            const { errors: batchErrors } = await BulkOperations.processBatch(
                products,
                null,
                (completed, total) => {
                    const progress = (completed / total) * 100;
                    progressBarInner.style.width = `${progress}%`;
                }
            );
            
            errors = batchErrors;
            
            if (errors.length === 0) {
                // Store batch operation in history
                operationHistory.push({
                    type: OperationTypes.BATCH_CATEGORY,
                    products: products.map(id => ({
                        receiptProductId: id,
                        category: this.currentCategory,
                        previousCategory: getCurrentCategory(id)
                    }))
                });
                
                showNotification('Kategoria została zaktualizowana dla wszystkich produktów!', 2000);
                products.forEach(id => updateProductCategory(id, this.currentCategory));
                updateUndoRedoButtons();
            } else {
                showError(
                    `Zaktualizowano ${products.length - errors.length} z ${products.length} produktów. ${errors.length} błędów.`,
                    ErrorTypes.VALIDATION
                );
            }
        } catch (error) {
            console.error('Error:', error);
            showError(
                'Wystąpił błąd podczas aktualizacji kategorii',
                ErrorTypes.SERVER
            );
        } finally {
            setTimeout(() => {
                progressBar.style.display = 'none';
                progressBarInner.style.width = '0%';
            }, 1000);
        }
    }
};

function toggleBatchCategoryMode() {
    const modal = new bootstrap.Modal(document.getElementById('batchCategoryModal'));
    BatchCategoryMapping.init();
    modal.show();
}

function filterBatchProducts() {
    BatchCategoryMapping.updateProductsList();
}

function toggleSelectAllBatch() {
    BatchCategoryMapping.toggleSelectAll();
}

function applyBatchCategory() {
    BatchCategoryMapping.currentCategory = document.getElementById('batchCategorySelect').value;
    BatchCategoryMapping.applyCategory();
}

function getCurrentCategory(productId) {
    const row = document.querySelector(`button[data-bs-target='#mapModal${productId}']`).closest('tr');
    const categoryCell = row.querySelector('td:nth-child(2)');
    return categoryCell ? categoryCell.textContent : '';
}

function updateProductCategory(productId, category) {
    const row = document.querySelector(`button[data-bs-target='#mapModal${productId}']`).closest('tr');
    const categoryCell = row.querySelector('td:nth-child(2)');
    if (categoryCell) {
        categoryCell.textContent = category;
    }
}

// Add undo/redo support for batch category operations
async function undoBatchCategory(operation) {
    const progressBar = document.getElementById('bulkProgress');
    const progressBarInner = progressBar.querySelector('.progress-bar');
    progressBar.style.display = 'flex';
    progressBarInner.style.width = '0%';
    
    const products = operation.products;
    let completed = 0;
    
    try {
        for (const product of products) {
            await fetch(`/api/produkty/kategoria/${product.receiptProductId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': getCsrfToken()
                },
                body: JSON.stringify({
                    category: product.previousCategory
                })
            });
            
            completed++;
            const progress = (completed / products.length) * 100;
            progressBarInner.style.width = `${progress}%`;
            
            updateProductCategory(product.receiptProductId, product.previousCategory);
        }
        
        showNotification('Kategorie zostały przywrócone!', 2000);
    } catch (error) {
        console.error('Error during undo:', error);
        showError('Wystąpił błąd podczas cofania zmian kategorii', ErrorTypes.SERVER);
    } finally {
        setTimeout(() => {
            progressBar.style.display = 'none';
            progressBarInner.style.width = '0%';
        }, 1000);
    }
}

async function redoBatchCategory(operation) {
    const progressBar = document.getElementById('bulkProgress');
    const progressBarInner = progressBar.querySelector('.progress-bar');
    progressBar.style.display = 'flex';
    progressBarInner.style.width = '0%';
    
    const products = operation.products;
    let completed = 0;
    
    try {
        for (const product of products) {
            await fetch(`/api/produkty/kategoria/${product.receiptProductId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': getCsrfToken()
                },
                body: JSON.stringify({
                    category: product.category
                })
            });
            
            completed++;
            const progress = (completed / products.length) * 100;
            progressBarInner.style.width = `${progress}%`;
            
            updateProductCategory(product.receiptProductId, product.category);
        }
        
        showNotification('Kategorie zostały ponownie zastosowane!', 2000);
    } catch (error) {
        console.error('Error during redo:', error);
        showError('Wystąpił błąd podczas ponownego zastosowania kategorii', ErrorTypes.SERVER);
    } finally {
        setTimeout(() => {
            progressBar.style.display = 'none';
            progressBarInner.style.width = '0%';
        }, 1000);
    }
}
</script>
{% endblock %} 